CFG: _OSSwapInt16
#0000:	 assign: *tmp0 = _data
 - no source -
#0001:	 assign: tmp1 = *tmp0 << 8
_OSByteOrder.h:50 return ((__uint16_t)((_data << 8) | (_data >> 8)));
#0002:	 assign: tmp2 = *tmp0 >> 8
_OSByteOrder.h:50 return ((__uint16_t)((_data << 8) | (_data >> 8)));
#0003:	 assign: tmp3 = tmp1 | tmp2
_OSByteOrder.h:50 return ((__uint16_t)((_data << 8) | (_data >> 8)));
#0004:	 noop: opcode 'LLVMTrunc' not supported
_OSByteOrder.h:50 return ((__uint16_t)((_data << 8) | (_data >> 8)));
#0005:	 noop: opcode 'LLVMRet' not supported <exit>
_OSByteOrder.h:50 return ((__uint16_t)((_data << 8) | (_data >> 8)));

CFG: _OSSwapInt32
#0000:	 assign: *tmp0 = _data
 - no source -
#0001:	 call: tmp1 = llvm.bswap.i32(*tmp0)
_OSByteOrder.h:60 return __builtin_bswap32(_data);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
_OSByteOrder.h:60 return __builtin_bswap32(_data);

CFG: _OSSwapInt64
#0000:	 assign: *tmp0 = _data
 - no source -
#0001:	 call: tmp1 = llvm.bswap.i64(*tmp0)
_OSByteOrder.h:74 return __builtin_bswap64(_data);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
_OSByteOrder.h:74 return __builtin_bswap64(_data);

CFG: CFRangeMake
#0000:	 assign: *tmp0 = loc
 - no source -
#0001:	 assign: *tmp1 = len
 - no source -
#0002:	 assign: *((tmp2+0).field0) = *tmp0
CFBase.h:380 range.location = loc;
#0003:	 assign: *((tmp2+0).field1) = *tmp1
CFBase.h:381 range.length = len;
#0004:	 assign: tmp3 = tmp4
CFBase.h:382 return range;
#0005:	 assign: tmp5 = tmp2
CFBase.h:382 return range;
#0006:	 call: llvm.memcpy.p0i8.p0i8.i64(tmp3, tmp5, 16, 8, 0)
CFBase.h:382 return range;
#0007:	 assign: tmp6 = tmp4
CFBase.h:382 return range;
#0008:	 noop: opcode 'LLVMRet' not supported <exit>
CFBase.h:382 return range;

CFG: OSReadSwapInt16
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:47 result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:47 result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:47 result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:47 result = *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0006:	 call: tmp2 = _OSSwapInt16(*tmp3)
OSByteOrder.h:48 return _OSSwapInt16(result);
#0007:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:48 return _OSSwapInt16(result);

CFG: OSReadSwapInt32
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:60 result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:60 result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:60 result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:60 result = *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0006:	 call: tmp2 = _OSSwapInt32(*tmp3)
OSByteOrder.h:61 return _OSSwapInt32(result);
#0007:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:61 return _OSSwapInt32(result);

CFG: OSReadSwapInt64
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:73 result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:73 result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:73 result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:73 result = *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0006:	 call: tmp2 = _OSSwapInt64(*tmp3)
OSByteOrder.h:74 return _OSSwapInt64(result);
#0007:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:74 return _OSSwapInt64(result);

CFG: OSWriteSwapInt16
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 call: tmp3 = _OSSwapInt16(*tmp2)
OSByteOrder.h:87 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:87 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
#0005:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:87 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
#0006:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:87 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);
#0007:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:87 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = _OSSwapInt16(data);

CFG: OSWriteSwapInt32
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 call: tmp3 = _OSSwapInt32(*tmp2)
OSByteOrder.h:98 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:98 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
#0005:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:98 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
#0006:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:98 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);
#0007:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:98 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = _OSSwapInt32(data);

CFG: OSWriteSwapInt64
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 call: tmp3 = _OSSwapInt64(*tmp2)
OSByteOrder.h:109 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:109 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
#0005:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:109 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
#0006:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:109 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);
#0007:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:109 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = _OSSwapInt64(data);

CFG: OSHostByteOrder
#0000:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:68 return OSLittleEndian;

CFG: _OSReadInt16
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:94 return *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:94 return *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:94 return *(volatile uint16_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:94 return *(volatile uint16_t *)((uintptr_t)base + byteOffset);

CFG: _OSReadInt32
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:104 return *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:104 return *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:104 return *(volatile uint32_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:104 return *(volatile uint32_t *)((uintptr_t)base + byteOffset);

CFG: _OSReadInt64
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:114 return *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:114 return *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0004:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:114 return *(volatile uint64_t *)((uintptr_t)base + byteOffset);
#0005:	 noop: opcode 'LLVMRet' not supported <exit>
OSByteOrder.h:114 return *(volatile uint64_t *)((uintptr_t)base + byteOffset);

CFG: _OSWriteInt16
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:127 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:127 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:127 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;
#0006:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:127 *(volatile uint16_t *)((uintptr_t)base + byteOffset) = data;

CFG: _OSWriteInt32
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:138 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:138 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:138 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;
#0006:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:138 *(volatile uint32_t *)((uintptr_t)base + byteOffset) = data;

CFG: _OSWriteInt64
#0000:	 assign: *tmp0 = base
 - no source -
#0001:	 assign: *tmp1 = byteOffset
 - no source -
#0002:	 assign: *tmp2 = data
 - no source -
#0003:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:149 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;
#0004:	 noop: opcode 'LLVMPtrToInt' not supported
OSByteOrder.h:149 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;
#0005:	 noop: opcode 'LLVMIntToPtr' not supported
OSByteOrder.h:149 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;
#0006:	 noop: opcode 'LLVMIntToPtr' not supported <exit>
OSByteOrder.h:149 *(volatile uint64_t *)((uintptr_t)base + byteOffset) = data;

CFG: CFByteOrderGetCurrent
#0000:	 call: tmp0 = OSHostByteOrder()
CFByteOrder.h:25 int32_t byteOrder = OSHostByteOrder();
#0001:	 noop: opcode 'LLVMCall' not supported
CFByteOrder.h:25 int32_t byteOrder = OSHostByteOrder();
#0002:	 noop: opcode 'LLVMSwitch' not supported <exit>
CFByteOrder.h:26 switch (byteOrder) {

CFG: CFSwapInt16
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt16(*tmp0)
CFByteOrder.h:45 return OSSwapInt16(arg);
#0002:	 noop: opcode 'LLVMTrunc' not supported
CFByteOrder.h:45 return OSSwapInt16(arg);
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:45 return OSSwapInt16(arg);

CFG: CFSwapInt32
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt32(*tmp0)
CFByteOrder.h:55 return OSSwapInt32(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:55 return OSSwapInt32(arg);

CFG: CFSwapInt64
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt64(*tmp0)
CFByteOrder.h:65 return OSSwapInt64(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:65 return OSSwapInt64(arg);

CFG: CFSwapInt16BigToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt16(*tmp0)
CFByteOrder.h:80 return OSSwapBigToHostInt16(arg);
#0002:	 noop: opcode 'LLVMTrunc' not supported
CFByteOrder.h:80 return OSSwapBigToHostInt16(arg);
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:80 return OSSwapBigToHostInt16(arg);

CFG: CFSwapInt32BigToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt32(*tmp0)
CFByteOrder.h:90 return OSSwapBigToHostInt32(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:90 return OSSwapBigToHostInt32(arg);

CFG: CFSwapInt64BigToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt64(*tmp0)
CFByteOrder.h:100 return OSSwapBigToHostInt64(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:100 return OSSwapBigToHostInt64(arg);

CFG: CFSwapInt16HostToBig
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt16(*tmp0)
CFByteOrder.h:110 return OSSwapHostToBigInt16(arg);
#0002:	 noop: opcode 'LLVMTrunc' not supported
CFByteOrder.h:110 return OSSwapHostToBigInt16(arg);
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:110 return OSSwapHostToBigInt16(arg);

CFG: CFSwapInt32HostToBig
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt32(*tmp0)
CFByteOrder.h:120 return OSSwapHostToBigInt32(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:120 return OSSwapHostToBigInt32(arg);

CFG: CFSwapInt64HostToBig
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 call: tmp1 = _OSSwapInt64(*tmp0)
CFByteOrder.h:130 return OSSwapHostToBigInt64(arg);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:130 return OSSwapHostToBigInt64(arg);

CFG: CFSwapInt16LittleToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:140 return OSSwapLittleToHostInt16(arg);

CFG: CFSwapInt32LittleToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:150 return OSSwapLittleToHostInt32(arg);

CFG: CFSwapInt64LittleToHost
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:160 return OSSwapLittleToHostInt64(arg);

CFG: CFSwapInt16HostToLittle
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:170 return OSSwapHostToLittleInt16(arg);

CFG: CFSwapInt32HostToLittle
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:180 return OSSwapHostToLittleInt32(arg);

CFG: CFSwapInt64HostToLittle
#0000:	 assign: *tmp0 = arg
 - no source -
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
CFByteOrder.h:190 return OSSwapHostToLittleInt64(arg);

CFG: NSSwapInt
#0000:	 assign: *tmp0 = inv
 - no source -
#0001:	 call: tmp1 = CFSwapInt32(*tmp0)
NSByteOrder.h:23 return CFSwapInt32(inv);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:23 return CFSwapInt32(inv);

CFG: NSSwapLongLong
#0000:	 assign: *tmp0 = inv
 - no source -
#0001:	 call: tmp1 = CFSwapInt64(*tmp0)
NSByteOrder.h:35 return CFSwapInt64(inv);
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:35 return CFSwapInt64(inv);

CFG: NSConvertSwappedFloatToHost
#0000:	 assign: *((tmp0+0).field0) = x.coerce
 - no source -
#0001:	 noop: Can't parse LLVMFloatTypeKind
NSByteOrder.h:135 return ((union fconv *)&x)->number;
#0002:	 noop: Can't parse LLVMFloatTypeKind
NSByteOrder.h:135 return ((union fconv *)&x)->number;
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:135 return ((union fconv *)&x)->number;

CFG: NSConvertSwappedDoubleToHost
#0000:	 assign: *((tmp0+0).field0) = x.coerce
 - no source -
#0001:	 noop: Can't parse LLVMDoubleTypeKind
NSByteOrder.h:151 return ((union dconv *)&x)->number;
#0002:	 noop: Can't parse LLVMDoubleTypeKind
NSByteOrder.h:151 return ((union dconv *)&x)->number;
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:151 return ((union dconv *)&x)->number;

CFG: NSSwapFloat
#0000:	 assign: *((tmp0+0).field0) = x.coerce
 - no source -
#0001:	 call: tmp1 = NSSwapInt(*((tmp0+0).field0))
NSByteOrder.h:155 x.v = NSSwapInt(x.v);
#0002:	 noop: opcode 'LLVMCall' not supported
NSByteOrder.h:155 x.v = NSSwapInt(x.v);
#0003:	 assign: tmp2 = tmp3
NSByteOrder.h:156 return x;
#0004:	 assign: tmp4 = tmp0
NSByteOrder.h:156 return x;
#0005:	 call: llvm.memcpy.p0i8.p0i8.i64(tmp2, tmp4, 4, 4, 0)
NSByteOrder.h:156 return x;
#0006:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:156 return x;

CFG: NSSwapDouble
#0000:	 assign: *((tmp0+0).field0) = x.coerce
 - no source -
#0001:	 call: tmp1 = NSSwapLongLong(*((tmp0+0).field0))
NSByteOrder.h:160 x.v = NSSwapLongLong(x.v);
#0002:	 noop: opcode 'LLVMCall' not supported
NSByteOrder.h:160 x.v = NSSwapLongLong(x.v);
#0003:	 assign: tmp2 = tmp3
NSByteOrder.h:161 return x;
#0004:	 assign: tmp4 = tmp0
NSByteOrder.h:161 return x;
#0005:	 call: llvm.memcpy.p0i8.p0i8.i64(tmp2, tmp4, 8, 8, 0)
NSByteOrder.h:161 return x;
#0006:	 noop: opcode 'LLVMRet' not supported <exit>
NSByteOrder.h:161 return x;

CFG: UCIsSurrogateHighCharacter
#0000:	 assign: *tmp0 = character
 - no source -
#0001:	 assign: tmp1 = *tmp0 & 64512
TextCommon.h:1107 return ( ( character & 0xFC00 ) == kUCHighSurrogateRangeStart );
#0002:	 assign: tmp2 = tmp1 == 55296
TextCommon.h:1107 return ( ( character & 0xFC00 ) == kUCHighSurrogateRangeStart );
#0003:	 noop: opcode 'LLVMTrunc' not supported
TextCommon.h:1107 return ( ( character & 0xFC00 ) == kUCHighSurrogateRangeStart );
#0004:	 noop: opcode 'LLVMRet' not supported <exit>
TextCommon.h:1107 return ( ( character & 0xFC00 ) == kUCHighSurrogateRangeStart );

CFG: UCIsSurrogateLowCharacter
#0000:	 assign: *tmp0 = character
 - no source -
#0001:	 assign: tmp1 = *tmp0 & 64512
TextCommon.h:1118 return ( ( character & 0xFC00 ) == kUCLowSurrogateRangeStart );
#0002:	 assign: tmp2 = tmp1 == 56320
TextCommon.h:1118 return ( ( character & 0xFC00 ) == kUCLowSurrogateRangeStart );
#0003:	 noop: opcode 'LLVMTrunc' not supported
TextCommon.h:1118 return ( ( character & 0xFC00 ) == kUCLowSurrogateRangeStart );
#0004:	 noop: opcode 'LLVMRet' not supported <exit>
TextCommon.h:1118 return ( ( character & 0xFC00 ) == kUCLowSurrogateRangeStart );

CFG: UCGetUnicodeScalarValueForSurrogatePair
#0000:	 assign: *tmp0 = surrogateHigh
 - no source -
#0001:	 assign: *tmp1 = surrogateLow
 - no source -
#0002:	 assign: tmp2 = *tmp0 - 55296
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
#0003:	 assign: tmp3 = tmp2 << 10
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
#0004:	 assign: tmp4 = *tmp1 - 56320
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
#0005:	 assign: tmp5 = tmp3 + tmp4
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
#0006:	 assign: tmp6 = tmp5 + 65536
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;
#0007:	 noop: opcode 'LLVMRet' not supported <exit>
TextCommon.h:1131 return ( (UnicodeScalarValue)( surrogateHigh - kUCHighSurrogateRangeStart ) << 10 ) + ( surrogateLow - kUCLowSurrogateRangeStart ) + 0x0010000;

CFG: SInt64ToWide
#0000:	 assign: *tmp0 = s
 - no source -
#0001:	 noop: opcode 'LLVMLShr' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0002:	 noop: opcode 'LLVMLShr' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0003:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0004:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0005:	 assign: tmp1 = *tmp0 & 4294967295
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0006:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0007:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0008:	 assign: tmp2 = tmp3
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0009:	 assign: tmp4 = tmp5
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0010:	 call: llvm.memcpy.p0i8.p0i8.i64(tmp2, tmp4, 8, 2, 0)
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0011:	 assign: tmp6 = tmp3
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }
#0012:	 noop: opcode 'LLVMRet' not supported <exit>
Math64.h:1354 static inline wide SInt64ToWide(SInt64 s) { wide result; result.hi = (SInt32)(((UInt64)s >> 32) & 0xffffffffUL); result.lo = (UInt32)((UInt64)s & 0xffffffffUL); return result; }

CFG: WideToSInt64
#0000:	 assign: tmp0 = tmp1
 - no source -
#0001:	 assign: *tmp0 = w.coerce
 - no source -
#0002:	 noop: opcode 'LLVMSExt' not supported
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }
#0003:	 noop: opcode 'LLVMSExt' not supported
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }
#0004:	 assign: tmp2 = *tmp3 << 32
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }
#0005:	 assign: tmp4 = tmp2 | *((tmp1+0).lo)
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }
#0006:	 assign: *tmp3 = tmp4
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }
#0007:	 noop: opcode 'LLVMRet' not supported <exit>
Math64.h:1355 static inline SInt64 WideToSInt64(wide w) { SInt64 result = w.hi; result = (result << 32) | w.lo; return result; }

CFG: UInt64ToUnsignedWide
#0000:	 assign: *tmp0 = u
 - no source -
#0001:	 noop: opcode 'LLVMLShr' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0002:	 noop: opcode 'LLVMLShr' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0003:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0004:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0005:	 assign: tmp1 = *tmp0 & 4294967295
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0006:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0007:	 noop: opcode 'LLVMTrunc' not supported
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0008:	 assign: tmp2 = tmp3
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0009:	 assign: tmp4 = tmp5
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0010:	 call: llvm.memcpy.p0i8.p0i8.i64(tmp2, tmp4, 8, 2, 0)
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0011:	 assign: tmp6 = tmp3
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }
#0012:	 noop: opcode 'LLVMRet' not supported <exit>
Math64.h:1357 static inline UnsignedWide UInt64ToUnsignedWide(UInt64 u) { UnsignedWide result; result.hi = (UInt32)((u >> 32) & 0xffffffffUL); result.lo = (UInt32)(u & 0xffffffffUL); return result; }

CFG: UnsignedWideToUInt64
#0000:	 assign: tmp0 = tmp1
 - no source -
#0001:	 assign: *tmp0 = uw.coerce
 - no source -
#0002:	 assign: *tmp2 = *((tmp1+0).hi)
Math64.h:1358 static inline UInt64 UnsignedWideToUInt64(UnsignedWide uw) { UInt64 result = uw.hi; result = (result << 32) | uw.lo; return result; }
#0003:	 assign: tmp3 = *tmp2 << 32
Math64.h:1358 static inline UInt64 UnsignedWideToUInt64(UnsignedWide uw) { UInt64 result = uw.hi; result = (result << 32) | uw.lo; return result; }
#0004:	 assign: tmp4 = tmp3 | *((tmp1+0).lo)
Math64.h:1358 static inline UInt64 UnsignedWideToUInt64(UnsignedWide uw) { UInt64 result = uw.hi; result = (result << 32) | uw.lo; return result; }
#0005:	 assign: *tmp2 = tmp4
Math64.h:1358 static inline UInt64 UnsignedWideToUInt64(UnsignedWide uw) { UInt64 result = uw.hi; result = (result << 32) | uw.lo; return result; }
#0006:	 noop: opcode 'LLVMRet' not supported <exit>
Math64.h:1358 static inline UInt64 UnsignedWideToUInt64(UnsignedWide uw) { UInt64 result = uw.hi; result = (result << 32) | uw.lo; return result; }

CFG: _mm_packs_pi16
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_unpackhi_pi16
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_unpacklo_pi8
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_unpacklo_pi16
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_cmpgt_pi8
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_cmpgt_pi16
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __m1.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0004:	 assign: *tmp1 = __m2.coerce
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_setzero_si64
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_set_pi32
#0000:	 assign: *tmp0 = __i1
 - no source -
#0001:	 assign: *tmp1 = __i0
 - no source -
#0002:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0003:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0004:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0005:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0008:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_set_pi16
#0000:	 assign: *tmp0 = __s3
 - no source -
#0001:	 assign: *tmp1 = __s2
 - no source -
#0002:	 assign: *tmp2 = __s1
 - no source -
#0003:	 assign: *tmp3 = __s0
 - no source -
#0004:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0005:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0006:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0007:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0008:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0011:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0012:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_set_pi8
#0000:	 assign: *tmp0 = __b7
 - no source -
#0001:	 assign: *tmp1 = __b6
 - no source -
#0002:	 assign: *tmp2 = __b5
 - no source -
#0003:	 assign: *tmp3 = __b4
 - no source -
#0004:	 assign: *tmp4 = __b3
 - no source -
#0005:	 assign: *tmp5 = __b2
 - no source -
#0006:	 assign: *tmp6 = __b1
 - no source -
#0007:	 assign: *tmp7 = __b0
 - no source -
#0008:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0009:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0010:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0011:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0012:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0013:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0014:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0015:	 noop: opcode 'LLVMInsertElement' not supported
 - no source -
#0016:	 noop: Can't parse LLVMX86_MMXTypeKind
 - no source -
#0017:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0018:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0019:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0020:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: _mm_setzero_ps
#0000:	 noop: Can't parse LLVMVectorTypeKind
xmmintrin.h:614 return (__m128){ 0, 0, 0, 0 };
#0001:	 noop: opcode 'LLVMRet' not supported <exit>
xmmintrin.h:614 return (__m128){ 0, 0, 0, 0 };

CFG: _mm_cvtpi16_ps
#0000:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0001:	 assign: *tmp0 = __a.coerce
 - no source -
#0002:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0003:	 call: tmp1 = _mm_setzero_si64()
 - no source -
#0004:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0005:	 noop: opcode 'LLVMCall' not supported
 - no source -
#0006:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0007:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0008:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0009:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0010:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0011:	 call: tmp2 = _mm_cmpgt_pi16(*tmp3, *tmp4)
 - no source -
#0012:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0013:	 noop: opcode 'LLVMCall' not supported
 - no source -
#0014:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0015:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0016:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0017:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0018:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0019:	 call: tmp5 = _mm_unpackhi_pi16(*tmp6, *tmp7)
 - no source -
#0020:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0021:	 noop: opcode 'LLVMCall' not supported
 - no source -
#0022:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0023:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0024:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0025:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0026:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0027:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0028:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0029:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0030:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0031:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0032:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0033:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0034:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0035:	 call: tmp8 = _mm_unpacklo_pi16(*tmp9, *tmp10)
 - no source -
#0036:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0037:	 noop: opcode 'LLVMCall' not supported
 - no source -
#0038:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0039:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0040:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0041:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0042:	 noop: Can't parse LLVMVectorTypeKind
 - no source -
#0043:	 noop: opcode 'LLVMRet' not supported <exit>
 - no source -

CFG: OSAtomicIncrement32
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd32(1, *tmp0)
OSAtomic.h:113 { return OSAtomicAdd32(  1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:113 { return OSAtomicAdd32(  1, __theValue); }

CFG: OSAtomicIncrement32Barrier
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd32Barrier(1, *tmp0)
OSAtomic.h:124 { return OSAtomicAdd32Barrier(  1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:124 { return OSAtomicAdd32Barrier(  1, __theValue); }

CFG: OSAtomicDecrement32
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd32(-1, *tmp0)
OSAtomic.h:132 { return OSAtomicAdd32( -1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:132 { return OSAtomicAdd32( -1, __theValue); }

CFG: OSAtomicDecrement32Barrier
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd32Barrier(-1, *tmp0)
OSAtomic.h:143 { return OSAtomicAdd32Barrier( -1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:143 { return OSAtomicAdd32Barrier( -1, __theValue); }

CFG: OSAtomicIncrement64
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd64(1, *tmp0)
OSAtomic.h:176 { return OSAtomicAdd64(  1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:176 { return OSAtomicAdd64(  1, __theValue); }

CFG: OSAtomicIncrement64Barrier
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd64Barrier(1, *tmp0)
OSAtomic.h:187 { return OSAtomicAdd64Barrier(  1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:187 { return OSAtomicAdd64Barrier(  1, __theValue); }

CFG: OSAtomicDecrement64
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd64(-1, *tmp0)
OSAtomic.h:195 { return OSAtomicAdd64( -1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:195 { return OSAtomicAdd64( -1, __theValue); }

CFG: OSAtomicDecrement64Barrier
#0000:	 assign: *tmp0 = __theValue
 - no source -
#0001:	 call: tmp1 = OSAtomicAdd64Barrier(-1, *tmp0)
OSAtomic.h:206 { return OSAtomicAdd64Barrier( -1, __theValue); }
#0002:	 noop: opcode 'LLVMRet' not supported <exit>
OSAtomic.h:206 { return OSAtomicAdd64Barrier( -1, __theValue); }

CFG: main
#0000:	 assign: *tmp0 = 0
 - no source -
#0001:	 assign: *tmp1 = argc
 - no source -
#0002:	 assign: *tmp2 = argv
 - no source -
#0003:	 noop: null
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0004:	 noop: Can't parse LValue: i8* (i8*, i8*)* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0005:	 noop: opcode 'LLVMCall' not supported
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0006:	 assign: tmp3 = tmp4
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0007:	 noop: Can't parse LValue: i8* (i8*, i8*)* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to i8* (i8*, i8*)*)
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0008:	 noop: opcode 'LLVMCall' not supported
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0009:	 assign: *tmp5 = tmp6
hello.m:5 NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
#0010:	 noop: Can't parse LValue: i8* bitcast (%struct.NSConstantString* @_unnamed_cfstring_ to i8*)
hello.m:6 NSLog (@"Hello, World!");
#0011:	 assign: tmp7 = *tmp5
hello.m:7 [pool drain];
#0012:	 noop: Can't parse LValue: void (i8*, i8*)* bitcast (i8* (i8*, i8*, ...)* @objc_msgSend to void (i8*, i8*)*)
hello.m:7 [pool drain];
#0013:	 noop: opcode 'LLVMRet' not supported <exit>
hello.m:8 return 0;

